on:
  workflow_dispatch:
  push:
    branches:
      - main

name: Deploy Staging

jobs:
  deploy:
    name: Deploy
    runs-on: self-hosted
    environment: staging

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AUTONOMY_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AUTONOMY_AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-1

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build Indexer Image
      id: build-indexer-api-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: api-${{ github.sha }}
        DOCKERFILE: Dockerfile
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

    - name: Build Indexer Background Image
      id: build-indexer-background-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: background-${{ github.sha }}
        DOCKERFILE: Dockerfile-background
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

    - name: Build Indexer GRPC Image
      id: build-nft-indexer-grpc-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: grpc-${{ github.sha }}
        DOCKERFILE: Dockerfile-grpc
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

    - name: Build Provenance Indexer Image
      id: build-provenance-indexer-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: provenance-indexer-${{ github.sha }}
        DOCKERFILE: Dockerfile-provenance-indexer
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

    - name: Build Account Token Indexer Image
      id: build-account-token-indexer-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: account-token-indexer-${{ github.sha }}
        DOCKERFILE: Dockerfile-account-token-indexer
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

    - name: Build, Image Indexer Image
      id: build-image-indexer-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: image-indexer-${{ github.sha }}
        DOCKERFILE: Dockerfile-image-indexer
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

    - name: Build Event Processor Image
      id: build-event-processor-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: event-processor-${{ github.sha }}
        DOCKERFILE: Dockerfile-event-processor
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

    - name: Build Event Processor Ethereum Emitter Image
      id: build-event-processor-ethereum-emitter-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: ethereum-emitter-${{ github.sha }}
        DOCKERFILE: Dockerfile-ethereum-emitter
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

    - name: Build Event Processor Tezos Emitter Image
      id: build-event-processor-tezos-emitter-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: tezos-emitter-${{ github.sha }}
        DOCKERFILE: Dockerfile-tezos-emitter
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"

    - name: Sops Binary Installer
      uses: mdgreenwald/mozilla-sops-action@v1.1.0
      with:
        version: '3.7.1'
      id: install-sops

    - name: Setup helmfile (include kubectl and helm)
      uses: mamezou-tech/setup-helmfile@v1.0.0
      with:
        additional-helm-plugins: https://github.com/jkroepke/helm-secrets --version v3.8.3

    - name: Set eks cluster context
      uses: azure/k8s-set-context@v2
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets.STAGING_KUBECONFIG }}
      id: set-kubectl-context

    - name: Deploy
      env:
        GITHUB_SHA: ${{ github.sha }}
      run: |
        helmfile --environment staging -l app=indexer apply
        helmfile --environment staging -l app=image-indexer apply
        helmfile --environment staging -l app=event-processor apply
        helmfile --environment staging -l app=event-processor-tezos-emitter apply
