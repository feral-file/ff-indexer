on:
  workflow_dispatch:
  
name: Deploy Development
  
jobs:
  build-indexer-api:
    name: Build Indexer API Image
    runs-on: self-hosted
  
    steps:
    - name: Checkout
      uses: actions/checkout@v4
  
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AUTONOMY_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AUTONOMY_AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-1
  
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
  
    - name: Build Indexer API Image
      id: build-indexer-api-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: api-${{ github.sha }}
        DOCKERFILE: Dockerfile
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
  
  build-indexer-background:
    name: Build Indexer Background Image
    runs-on: self-hosted
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AUTONOMY_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AUTONOMY_AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-1
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    - name: Build Indexer Background Image
      id: build-indexer-background-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: background-${{ github.sha }}
        DOCKERFILE: Dockerfile-background
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
  
  build-indexer-grpc:
    name: Build Indexer GRPC Image
    runs-on: self-hosted
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
  
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AUTONOMY_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AUTONOMY_AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-1
  
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    - name: Build Indexer GRPC Image
      id: build-nft-indexer-grpc-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: grpc-${{ github.sha }}
        DOCKERFILE: Dockerfile-grpc
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
          
  build-indexer-provenance:
    name: Build Indexer Provenance Image
    runs-on: self-hosted
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
  
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AUTONOMY_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AUTONOMY_AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-1
  
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    - name: Build Provenance Indexer Image
      id: build-provenance-indexer-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: provenance-indexer-${{ github.sha }}
        DOCKERFILE: Dockerfile-provenance-indexer
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
  
  build-indexer-image-indexer:
    name: Build Indexer Image Indexer Image
    runs-on: self-hosted
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
  
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AUTONOMY_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AUTONOMY_AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-1
  
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    - name: Build Image Indexer Image
      id: build-image-indexer-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: image-indexer-${{ github.sha }}
        DOCKERFILE: Dockerfile-image-indexer
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
  
  build-indexer-event-processor:
    name: Build Event Processor Image
    runs-on: self-hosted
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
  
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AUTONOMY_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AUTONOMY_AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-1
  
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    - name: Build Event Processor Image
      id: build-event-processor-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: event-processor-${{ github.sha }}
        DOCKERFILE: Dockerfile-event-processor
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
  
  build-indexer-event-processor-ethereum-emitter:
    name: Build Event Processor Ethereum Emitter Image
    runs-on: self-hosted
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
  
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AUTONOMY_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AUTONOMY_AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-1
  
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    - name: Build Event Processor Ethereum Emitter Image
      id: build-event-processor-ethereum-emitter-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: ethereum-emitter-${{ github.sha }}
        DOCKERFILE: Dockerfile-ethereum-emitter
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
          
  build-indexer-event-processor-tezos-emitter:
    name: Build Event Processor Tezos Emitter Image
    runs-on: self-hosted
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
  
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AUTONOMY_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AUTONOMY_AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-1
  
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1
    - name: Build Event Processor Tezos Emitter Image
      id: build-event-processor-tezos-emitter-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: nft-indexer
        IMAGE_TAG: tezos-emitter-${{ github.sha }}
        DOCKERFILE: Dockerfile-tezos-emitter
        GITHUB_USER: bitmark-bot
        GITHUB_TOKEN: ${{ secrets.ACTION_BOT_GITHUB_TOKEN }}
      run: |
        # Build a docker container and push it to ECR so that it can be deployed.
        # Build & push the docker image (check access policy: autonomy-ecr-pull-push-images)
        if ! aws ecr describe-images --repository-name="${ECR_REPOSITORY}" --image-ids="imageTag=${IMAGE_TAG}" > /dev/null 2>&1
        then
          docker build --build-arg GITHUB_USER=${GITHUB_USER} --build-arg GITHUB_TOKEN=${GITHUB_TOKEN} --tag="${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}" --file="${DOCKERFILE}" "."
          docker push "${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
        fi
        echo "::set-output name=image::${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}"
  
  deploy:
    name: Deploy
    runs-on: self-hosted
    environment: development
  
    needs: 
    - build-indexer-api
    - build-indexer-background
    - build-indexer-grpc
    - build-indexer-provenance
    - build-indexer-image-indexer
    - build-indexer-event-processor
    - build-indexer-event-processor-ethereum-emitter
    - build-indexer-event-processor-tezos-emitter
  
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AUTONOMY_AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AUTONOMY_AWS_SECRET_ACCESS_KEY }}
        aws-region: ap-northeast-1

    - name: Set eks cluster context
      uses: azure/k8s-set-context@v2
      with:
        method: kubeconfig
        kubeconfig: ${{ secrets.DEVELOPMENT_KUBECONFIG_V2 }}
      id: set-kubectl-context
  
    - name: Deploy
      env:
        GITHUB_SHA: ${{ github.sha }}
      run: |
        helmfile --environment development -l app=indexer apply
        helmfile --environment development -l app=image-indexer apply
        helmfile --environment development -l app=event-processor apply
        helmfile --environment development -l app=event-processor-tezos-emitter apply
  