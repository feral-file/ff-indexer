package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"time"

	indexer "github.com/bitmark-inc/nft-indexer"
	indexerWorker "github.com/bitmark-inc/nft-indexer/background/worker"
	"github.com/bitmark-inc/nft-indexer/services/nft-indexer/graph/model"
	"github.com/ethereum/go-ethereum/common"
)

// IndexHistory is the resolver for the indexHistory field.
func (r *mutationResolver) IndexHistory(ctx context.Context, indexID string) (bool, error) {
	token, err := r.indexerStore.GetTokenByIndexID(ctx, indexID)
	if err != nil {
		return false, err
	}

	if token == nil {
		return false, fmt.Errorf("token does not exist")
	}

	if token.Fungible {
		indexerWorker.StartRefreshTokenOwnershipWorkflow(ctx, r.cadenceWorker, "indexer", indexID, 0)
	} else {
		indexerWorker.StartRefreshTokenProvenanceWorkflow(ctx, r.cadenceWorker, "indexer", indexID, 0)
	}

	return true, nil
}

// Tokens is the resolver for the tokens field.
func (r *queryResolver) Tokens(ctx context.Context, owners []string, ids []string, source string, lastUpdatedAt *time.Time, sortBy *string, offset int64, size int64) ([]*model.Token, error) {
	var tokensInfo []indexer.DetailedTokenV2
	var err error

	if len(ids) == 0 && len(owners) > 0 {
		queryLastUpdatedTime := time.Time{}
		if lastUpdatedAt != nil {
			queryLastUpdatedTime = *lastUpdatedAt
		}

		querySortBy := ""
		if sortBy != nil {
			querySortBy = *sortBy
		}

		tokensInfo, err = r.indexerStore.GetDetailedAccountTokensByOwners(
			ctx,
			owners,
			indexer.FilterParameter{
				Source: source,
			},
			queryLastUpdatedTime,
			querySortBy,
			offset,
			size,
		)
	} else if len((owners)) == 0 && len(ids) > 0 {
		tokensInfo, err = r.indexerStore.GetDetailedTokensV2(
			ctx, indexer.FilterParameter{
				IDs: ids,
			},
			offset,
			size)
	} else {
		return []*model.Token{}, fmt.Errorf("invalid query")
	}

	if err != nil {
		return []*model.Token{}, err
	}

	tokens := []*model.Token{}
	for _, t := range tokensInfo {
		tokens = append(tokens, r.mapGraphQLToken(t))
	}

	return tokens, nil
}

// Identity is the resolver for the identity field.
func (r *queryResolver) Identity(ctx context.Context, account string) (*model.Identity, error) {
	identity, err := r.indexerStore.GetIdentity(ctx, account)

	if err != nil {
		return nil, err
	}

	return r.mapGraphQLIdentity(identity), nil
}

// EthBlockTime is the resolver for the ethBlockTime field.
func (r *queryResolver) EthBlockTime(ctx context.Context, blockHash string) (*model.BlockTime, error) {
	blockTime, err := r.cacheClient.GetETHBlockTime(ctx, common.HexToHash(blockHash))
	if err != nil {
		return nil, err
	}

	return &model.BlockTime{BlockTime: blockTime}, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
