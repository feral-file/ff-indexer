package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"time"

	"github.com/bitmark-inc/nft-indexer"
	"github.com/bitmark-inc/nft-indexer/services/nft-indexer/graph/model"
)

// Nft is the resolver for the nft field.
func (r *queryResolver) Nft(ctx context.Context, owners []string, lastUpdatedAt *time.Time, offset int64, size int64) ([]*model.Token, error) {
	queryLastUpdatedTime := time.Time{}
	if lastUpdatedAt != nil {
		queryLastUpdatedTime = *lastUpdatedAt
	}

	tokensInfo, err := r.indexerStore.GetDetailedAccountTokensByOwners(
		ctx,
		owners,
		indexer.FilterParameter{},
		queryLastUpdatedTime,
		offset,
		size,
	)

	if err != nil {
		return []*model.Token{}, err
	}

	tokens := []*model.Token{}
	for _, t := range tokensInfo {
		tokens = append(tokens, r.mapGraphQLToken(t))
	}

	return tokens, nil
}

// Query is the resolver for the query field.
func (r *queryResolver) Query(ctx context.Context, ids []string, offset int64, size int64) ([]*model.Token, error) {
	tokensInfo, err := r.indexerStore.GetDetailedTokensV2(ctx, indexer.FilterParameter{
		IDs: ids,
	}, offset, size)

	if err != nil {
		return []*model.Token{}, err
	}

	tokens := []*model.Token{}
	for _, t := range tokensInfo {
		tokens = append(tokens, r.mapGraphQLToken(t))
	}

	return tokens, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
