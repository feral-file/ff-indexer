package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"
	"time"

	log "github.com/bitmark-inc/autonomy-logger"
	utils "github.com/bitmark-inc/autonomy-utils"
	indexer "github.com/bitmark-inc/nft-indexer"
	indexerWorker "github.com/bitmark-inc/nft-indexer/background/worker"
	"github.com/bitmark-inc/nft-indexer/services/nft-indexer/graph/model"
	"github.com/ethereum/go-ethereum/common"
)

// IndexHistory is the resolver for the indexHistory field.
func (r *mutationResolver) IndexHistory(ctx context.Context, indexID string) (bool, error) {
	token, err := r.indexerStore.GetTokenByIndexID(ctx, indexID)
	if err != nil {
		return false, err
	}

	if token == nil {
		return false, fmt.Errorf("token does not exist")
	}

	if token.Fungible {
		indexerWorker.StartRefreshTokenOwnershipWorkflow(ctx, r.cadenceWorker, "indexer", indexID, 0)
	} else {
		indexerWorker.StartRefreshTokenProvenanceWorkflow(ctx, r.cadenceWorker, "indexer", indexID, 0)
	}

	return true, nil
}

// IndexCollection is the resolver for the indexCollection field.
func (r *mutationResolver) IndexCollection(ctx context.Context, owners []string) (bool, error) {
	for _, owner := range owners {
		blockchain := utils.GetBlockchainByAddress(owner)

		switch blockchain {
		case utils.EthereumBlockchain:
			log.Debug("Not implemented")
		case utils.TezosBlockchain:
			indexerWorker.StartIndexTezosCollectionWorkflow(ctx, r.cadenceWorker, "indexer", owner)
		}
	}

	return true, nil
}

// Tokens is the resolver for the tokens field.
func (r *queryResolver) Tokens(ctx context.Context, owners []string, ids []string, collectionID string, source string, lastUpdatedAt *time.Time, sortBy *string, offset int64, size int64) ([]*model.Token, error) {
	var tokensInfo []indexer.DetailedTokenV2
	var err error

	if len(ids) == 0 && len(owners) > 0 {
		queryLastUpdatedTime := time.Time{}
		if lastUpdatedAt != nil {
			queryLastUpdatedTime = *lastUpdatedAt
		}

		querySortBy := ""
		if sortBy != nil {
			querySortBy = *sortBy
		}

		tokensInfo, err = r.indexerStore.GetDetailedAccountTokensByOwners(
			ctx,
			owners,
			indexer.FilterParameter{
				Source: source,
			},
			queryLastUpdatedTime,
			querySortBy,
			offset,
			size,
		)
	} else if len((owners)) == 0 && len(ids) > 0 {
		checksumIDs := indexer.NormalizeIndexIDs(ids, false)
		tokensInfo, err = r.indexerStore.GetDetailedTokensV2(
			ctx, indexer.FilterParameter{
				IDs: checksumIDs,
			},
			offset,
			size)
	} else if collectionID != "" {
		tokensInfo, err = r.indexerStore.GetDetailedTokensByCollectionID(
			ctx,
			collectionID,
			offset,
			size)
	} else {
		return []*model.Token{}, fmt.Errorf("invalid query")
	}

	if err != nil {
		return []*model.Token{}, err
	}

	tokens := []*model.Token{}
	for _, t := range tokensInfo {
		tokens = append(tokens, r.mapGraphQLToken(t))
	}

	return tokens, nil
}

// Identity is the resolver for the identity field.
func (r *queryResolver) Identity(ctx context.Context, account string) (*model.Identity, error) {
	identity, err := r.indexerStore.GetIdentity(ctx, account)

	if err != nil {
		return nil, err
	}

	return r.mapGraphQLIdentity(identity), nil
}

// EthBlockTime is the resolver for the ethBlockTime field.
func (r *queryResolver) EthBlockTime(ctx context.Context, blockHash string) (*model.BlockTime, error) {
	blockTime, err := indexer.GetETHBlockTime(ctx, r.cacheStore, r.ethClient, common.HexToHash(blockHash))
	if err != nil {
		return nil, err
	}

	return &model.BlockTime{BlockTime: blockTime}, nil
}

// Collections is the resolver for the collections field.
func (r *queryResolver) Collections(ctx context.Context, owners []string, offset int64, size int64) ([]*model.Collection, error) {
	collectionsInfo, err := r.indexerStore.GetCollectionsByOwners(ctx, owners, offset, size)

	if err != nil {
		return nil, err
	}

	collections := []*model.Collection{}
	for _, t := range collectionsInfo {
		collections = append(collections, r.mapGraphQLCollection(t))
	}

	return collections, nil
}

// Collection is the resolver for the collection field.
func (r *queryResolver) Collection(ctx context.Context, id string) (*model.Collection, error) {
	collectionInfo, err := r.indexerStore.GetCollectionByID(ctx, id)

	if err != nil {
		return nil, err
	}

	if collectionInfo == nil {
		return nil, fmt.Errorf("collection is not found")
	}

	return r.mapGraphQLCollection(*collectionInfo), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
