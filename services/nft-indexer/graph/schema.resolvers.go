package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"time"

	"github.com/bitmark-inc/nft-indexer"
	"github.com/bitmark-inc/nft-indexer/services/nft-indexer/graph/model"
)

// Tokens is the resolver for the tokens field.
func (r *queryResolver) Tokens(ctx context.Context, owners []string, ids []string, lastUpdatedAt *time.Time, sortBy *string, offset int64, size int64) ([]*model.Token, error) {
	var tokensInfo []indexer.DetailedTokenV2
	var err error

	if len(ids) == 0 && len(owners) > 0 {
		queryLastUpdatedTime := time.Time{}
		if lastUpdatedAt != nil {
			queryLastUpdatedTime = *lastUpdatedAt
		}

		querySortBy := ""
		if sortBy != nil {
			querySortBy = *sortBy
		}

		tokensInfo, err = r.indexerStore.GetDetailedAccountTokensByOwners(
			ctx,
			owners,
			indexer.FilterParameter{},
			queryLastUpdatedTime,
			querySortBy,
			offset,
			size,
		)
	} else if len((owners)) == 0 && len(ids) > 0 {
		tokensInfo, err = r.indexerStore.GetDetailedTokensV2(
			ctx, indexer.FilterParameter{
				IDs: ids,
			},
			offset,
			size)
	} else {
		return []*model.Token{}, fmt.Errorf("invalid query")
	}

	if err != nil {
		return []*model.Token{}, err
	}

	tokens := []*model.Token{}
	for _, t := range tokensInfo {
		tokens = append(tokens, r.mapGraphQLToken(t))
	}

	return tokens, nil
}

// Identity is the resolver for the identity field.
func (r *queryResolver) Identity(ctx context.Context, account string) (*model.Identity, error) {
	identity, err := r.indexerStore.GetIdentity(ctx, account)

	if err != nil {
		return nil, err
	}

	return r.mapGraphQLIdentity(identity), nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
